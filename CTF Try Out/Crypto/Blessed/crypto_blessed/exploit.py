from pwn import remote
from py_ecc.bls import G2ProofOfPossession as bls
import json

HOST = "83.136.253.201"
PORT = 41348
ROBOT_COUNT = 1
MESSAGE = b"unveil_secrets"

def wait_prompt(sock):
    sock.recvuntil(b">")

def send_json(sock, obj):
    sock.sendline(json.dumps(obj).encode())

def recv_json(sock, timeout=5):
    try:
        return json.loads(sock.recvline(timeout=timeout).decode())
    except Exception as e:
        print("[!] Error receiving data:", e)
        return None

def extract_sk_from_robot(sock, robot_id):
    try:
        # Verifying robot and waiting for sk leak
        send_json(sock, {
            "cmd": "verify",
            "robot_id": robot_id
        })

        # Capture the response from server which may contain the sk
        response = sock.recvuntil(b"\n", timeout=5).decode()
        if "sk =" in response:
            leaked_sk_str = response.split("sk =")[1].strip().split()[0]
            leaked_sk = int(leaked_sk_str, 16)
            print(f"[+] Leaked sk for robot {robot_id}: {leaked_sk}")
            return leaked_sk
        else:
            print(f"[-] No sk leaked for {robot_id}")
            return None
    except Exception as e:
        print(f"[!] Error verifying {robot_id}: {e}")
        return None

def main():
    print("[*] Connecting to server...")
    sock = remote(HOST, PORT)
    sock.recvuntil(b"}\n\n")
    wait_prompt(sock)

    sks, pks, robot_ids = [], [], []

    print("[*] Creating verified robots...")
    for _ in range(ROBOT_COUNT):
        send_json(sock, {"cmd": "create"})
        res = recv_json(sock)
        if not res:
            print("[!] Failed to create robot.")
            return

        sk = int(res["sk"], 16)
        pk = bytes.fromhex(res["pk"])
        robot_id = res["robot_id"]

        print(f"[+] Created robot: {robot_id}")
        sks.append(sk)
        pks.append(pk)
        robot_ids.append(robot_id)
        wait_prompt(sock)

    print("[*] Signing and aggregating signatures...")
    sigs = [bls.Sign(sk, MESSAGE) for sk in sks]
    agg_sig = bls.Aggregate(sigs)

    print("[*] Verifying locally...")
    if bls.FastAggregateVerify(pks, MESSAGE, agg_sig):
        print("[✓] Local verification passed.")
    else:
        print("[!] Local verification FAILED.")
        return

    print("[*] Getting list of robots from server...")
    list_sig = bls.Sign(sks[0], b"list")
    send_json(sock, {
        "cmd": "list",
        "robot_id": robot_ids[0],
        "sig": list_sig.hex()
    })
    robot_list = recv_json(sock)
    wait_prompt(sock)

    if not robot_list:
        print("[!] Failed to get robot list.")
        return

    print(f"[+] Total robots listed: {len(robot_list)}")
    server_robot_ids = []
    all_pks = []
    for r in robot_list:
        rid = r["robot_id"]
        pk = bytes.fromhex(r["pk"])
        all_pks.append(pk)
        if rid not in robot_ids:
            server_robot_ids.append(rid)
            print(f"[!] Found server-made robot: {rid}")
        else:
            print(f"[✓] Our robot: {rid}")

    print("[*] Trying to verify server-made robots and steal sks...")
    for server_robot_id in server_robot_ids:
        leaked_sk = extract_sk_from_robot(sock, server_robot_id)
        if leaked_sk:
            sks.append(leaked_sk)
            pks.append(bytes.fromhex([
                r["pk"] for r in robot_list if r["robot_id"] == server_robot_id
            ][0]))

    # Continue the process with the unveil_secrets request
    print("[*] Sending unveil_secrets request...")
    send_json(sock, {
        "cmd": "unveil_secrets",
        "sig": agg_sig.hex()
    })

    try:
        resp = recv_json(sock, timeout=10)
        if resp is None:
            print("[!] No response received from the server.")
        else:
            print("[*] Server response:\n", json.dumps(resp, indent=2))
    except Exception as e:
        print("[!] Failed to receive response:", e)

    sock.close()
    print("[*] Closed connection to server.")

if __name__ == "__main__":
    main()
